#lang typed/racket/base

(require "../primop.rkt" "../ir-anf-ast.rkt" "../types.rkt" "inline.rkt")

(require racket/match)
(provide inline-trivial)

(: expression-size (expression -> Real))
(define (expression-size expr)
 (: recur (expression -> Real))
 (define (recur expr)
  (match expr
   ((return name) 0)
   ((conditional c t f ty)
    (+ 1 (recur t) (recur f)))
   ((bind-primop var ty op args expr)
    (+ (recur expr)
     (match op
      ((unit-primop) 0)
      ((integer-constant-primop n) 0)
      ((string-constant-primop str) 0)
      ((unit-primop) 0)
      ((nil-primop ty) 0)
      ((runtime-primop ty name) 1)
      ((math-primop sym) 1)
      ((equality-primop eql ty) 1)
      ((call-closure-primop ty) 1)
      ((call-known-function-primop ty name) 1)
      ((call-known-runtime-primop ty name) 1)
      ((create-box-primop ty) 1)
      ((create-array-primop ty) 1)
      ((create-record-primop ty) 1)
      ((box-ref-primop ty) 1)
      ((array-ref-primop ty) 1)
      ((field-ref-primop ty name) 1)
      ((box-set!-primop ty) 1)
      ((array-set!-primop ty) 1)
      ((field-set!-primop ty name) 1)
      (else (error 'expression-size "Not yet implemented ~a" op)))))
   ((bind-rec funs expr)
    (+ (recur expr)
       (foldl + 0 (map (lambda: ((p : (Pair unique function))) (recur (function-body (cdr p)))) funs))))))
 (recur expr))

(: function-size (function -> Real))
(define (function-size fun)
 (expression-size (function-body fun)))

(: inline-trivial (expression -> expression))
(define (inline-trivial expr)
 (: fix (type -> (expression -> expression)))
 (define (fix return-type)
  (: recur (expression -> expression))
  (define (recur expr)
   (match expr
    ((return name) expr)
    ((bind-primop var ty op args expr)
     (bind-primop var ty op args (recur expr)))
    ((conditional c t f ty)
     (conditional c (recur t) (recur f) ty))
    ((bind-rec funs body)
     (let ((expr
       (for/fold: : bind-rec
        ((expr : bind-rec (bind-rec funs (recur body))))
        ((fun : (Pair unique function) funs))
         (if (>= 1 (function-size (cdr fun)))
             (smart-inline-except-self (car fun) (cdr fun) expr return-type)
             expr))))
      (match expr
       ((bind-rec funs body)
        (bind-rec (map (lambda: ((p : (Pair unique function)))
         (cons (car p)
          (match (cdr p)
           ((function name args ty body)
            (function name args ty (recur body)))))) funs) body)))))))
  recur)
 ((fix unit-type) expr))


