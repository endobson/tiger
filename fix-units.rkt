#lang typed/racket/base

(require "types.rkt" "ir-ast.rkt" "primop.rkt")
(require racket/list racket/match)

(provide remove-units)

(: remove-units (expression -> expression))
(define (remove-units expr)
 (define-type environment (HashTable Symbol #t))
 (: fix-function (environment -> ((Pair Symbol function) -> (Pair Symbol function))))
 (define ((fix-function env) pair)
  (cons (car pair)
   (match (cdr pair)
    ((function args return body)
     (let* ((bad-args (filter-map (lambda: ((arg : (Pair Symbol type))) (and (unit-type? (cdr arg)) (car arg))) args))
            (good-args (filter (lambda: ((arg : (Pair Symbol type))) (not (unit-type? (cdr arg)))) args))
            (env (for/fold: : environment ((env : environment env)) ((arg : Symbol bad-args)) (hash-set env arg #t))))
      (function good-args return ((fix env) body)))))))

 (: unit expression)
 (define unit (primop-expr (unit-primop) empty))
 (: fix (environment -> (expression -> expression)))
 (define (fix env)
  (: recur (expression -> expression))
  (define (recur expr)
   (match expr
    ((identifier name) (if (hash-has-key? env name) unit expr))
    ((primop-expr op args)
     (match op
      ((call-closure-primop ty)
       (let* ((arg-types (function-type-arg-types ty))
              (unit-slots (map unit-type? arg-types))
              (has-unit (ormap (inst values Boolean) unit-slots)))
        (if has-unit
            (let ((names (map (lambda (t) (gensym 'temp)) arg-types)))
             (for/fold: : expression
              ((expr : expression (primop-expr op (map identifier names))))
              ((name : Symbol (reverse names))
               (unit? : Boolean (reverse unit-slots))
               (ty : type (reverse arg-types))
               (arg : expression (reverse args)))
              (if unit?
                  (sequence (recur arg) expr)
                  (bind name ty (recur arg) expr))))
            (primop-expr op (map recur args)))))
      (else (primop-expr op (map recur args)))))
    ((bind var ty expr body)
     (if (unit-type? ty)
         (sequence (recur expr) ((fix (hash-set env var #t)) body))
         (bind var ty (recur expr) (recur body))))
    ((bind-rec funs body)
     (bind-rec (map (fix-function env) funs) (recur body)))
    ((sequence first next)
     (sequence (recur first) (recur next)))
    ((conditional c t f ty)
     (conditional (recur c) (recur t) (recur f) ty))))
  recur)
 ((fix (make-immutable-hash empty)) expr))
