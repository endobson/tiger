#lang typed/racket/base

(require "types.rkt" "ir-ast.rkt" "primop.rkt")

(require racket/list racket/match)

(provide type-check)

(: type-check (expression -> Void))
(define (type-check expr)
 (define-type environment (HashTable Symbol type))


 (: check (environment -> (expression -> type)))
 (define (check env)
  (: type-assert (expression type -> Void))
  (define (type-assert expr expected)
   (let ((actual (recur expr)))
    (unless (equal? actual expected)
     (error 'type-check "Expression ~a has type ~a. Expected ~a." expr actual expected))))

  (: assert (Boolean -> Void))
  (define (assert bool)
   (unless bool
    (error 'type-check "Some invariant violated")))

  (: recur (expression -> type))
  (define (recur expr)
   (match expr
    ((primop-expr op args)
     (match op
      ((integer-constant-primop n) (assert (empty? args)) int-type)
      ((string-constant-primop str) (assert (empty? args)) string-type)
      ((unit-primop) (assert (empty? args)) unit-type)
      ((nil-primop ty) (assert (empty? args)) ty)
      ((runtime-primop ty name) (assert (empty? args)) ty)
      ((math-primop sym)
       (assert (= (length args) 2))
       (type-assert (first args) int-type)
       (type-assert (second args) int-type)
       int-type)
      ((equality-primop eql ty)
       (assert (= (length args) 2))
       (type-assert (first args) ty)
       (type-assert (second args) ty)
       int-type)
      ((call-closure-primop ty)
       (let ((arg-types (function-type-arg-types ty)))
        (type-assert (first args) ty)
        (for-each (lambda: ((arg : expression) (ty : type)) (type-assert arg ty)) (rest args) arg-types)
          (function-type-return-type ty)))
      ((create-box-primop ty) 
       (assert (= (length args) 1))
       (type-assert (first args) (box-type-elem-type ty))
       ty)
      ((create-array-primop ty) 
       (assert (= (length args) 2))
       (type-assert (first args) int-type)
       (type-assert (second args) (array-type-elem-type ty))
       ty)
      ((create-record-primop ty)
       (let ((fields (map (inst cdr Symbol type) (record-type-fields ty))))
        (assert (= (length args) (length fields)))
        (for-each type-assert args fields)
        ty))
      ((box-ref-primop ty)
       (assert (= (length args) 1))
       (type-assert (first args) ty)
       (box-type-elem-type ty))
      ((array-ref-primop ty)
       (assert (= (length args) 2))
       (type-assert (first args) ty)
       (type-assert (second args) int-type)
       (array-type-elem-type ty))
      ((field-ref-primop ty name)
       (assert (= (length args) 1))
       (type-assert (first args) ty)
       (record-type-field-type ty name))
      ((box-set!-primop ty)
       (assert (= (length args) 2))
       (type-assert (first args) ty)
       (type-assert (second args) (box-type-elem-type ty))
       unit-type)
      ((array-set!-primop ty)
       (assert (= (length args) 3))
       (type-assert (first args) ty)
       (type-assert (second args) int-type)
       (type-assert (third args) (array-type-elem-type ty))
       unit-type)
      ((field-set!-primop ty name)
       (assert (= (length args) 2))
       (type-assert (first args) ty)
       (type-assert (second args) (record-type-field-type ty name))
       unit-type)


      (else (error 'type-check "Not yet implemented ~a" op))))
    ((conditional c t f ty)
     (type-assert c int-type)
     (type-assert t ty)
     (type-assert f ty)
     ty)
    ((bind var ty expr body) 
     (type-assert expr ty)
     ((check (hash-set env var ty)) body))
    ((bind-rec funs body)
     (let ((env (for/fold: : environment
                  ((env : environment env))
                  ((pair : (Pair Symbol function) funs))
                  (hash-set env (car pair) (function->function-type (cdr pair))))))
      (for-each (check-function env) (map (inst cdr Symbol function) funs))
      ((check env) body)))
    ((sequence first next)
     (recur first) (recur next))
    ((identifier name)
     (hash-ref env name
      (lambda () (error 'type-check "Unbound identifier ~a in ~a" name env))))))
  recur)

 (: check-function (environment -> (function -> Void)))
 (define ((check-function env) fun)
  (match fun
   ((function args return body)
    (let ((env (for/fold: : environment
                 ((env : environment env))
                 ((arg : (Pair Symbol type) args))
                (hash-set env (car arg) (cdr arg)))))
     (let ((ty ((check env) body)))
      (unless (equal? ty return)
       (error 'type-check "Body of function has return type ~a which doesn't match expected ~a" ty return)))))))

  
  

 ((check (make-immutable-hash empty)) expr)
 (void))

